§u§
Create a simple flask app which returns the user agent.
§a§
Here is a simple Flask application that returns the user agent string submitted in the request headers.

### 1. Prerequisites

You need to have Python and Flask installed. If you don't have Flask, install it using pip:

```bash
pip install Flask
```

### 2. Flask Application Code (`app.py`)

Create a file named `app.py` and add the following code:

```python
from flask import Flask, request

# Create the Flask application instance
app = Flask(__name__)

@app.route('/')
def get_user_agent():
    """
    This route handles GET requests and returns the User-Agent string
    from the request headers.
    """
    # The 'User-Agent' header is accessed via request.headers
    user_agent = request.headers.get('User-Agent')

    if user_agent:
        # Format the output nicely
        return f"<h1>Your User Agent is:</h1><p>{user_agent}</p>"
    else:
        return "<h1>No User-Agent found in the request headers.</h1>"

# This block allows you to run the application directly
if __name__ == '__main__':
    # Run the app on http://127.0.0.1:5000/
    app.run(debug=True)
```

### 3. How to Run the Application

1. **Open your terminal or command prompt.**
2. **Navigate to the directory** where you saved `app.py`.
3. **Run the application** using the Python interpreter:

   ```bash
   python app.py
   ```

4. You will see output similar to this, indicating the server is running:

   ```
    * Serving Flask app 'app'
    * Debug mode: on
    * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
    * Restarting with stat
    ...
   ```

### 4. How to Test It

1. **Open your web browser** (like Chrome, Firefox, or Safari).
2. **Navigate to the address:** `http://127.0.0.1:5000/`

The page will display the User Agent string that your browser sent when making the request.

**Example Output in Browser (if using Chrome):**

> **Your User Agent is:**
> Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
§u§
Assume the `get_user_agent()` has been moved to another file is being imported. How is it possible to make the `@app.route()` still work?
§a§
If the route function (`get_user_agent`) is moved to another file (e.g., `my_routes.py`), you need to ensure two things for the main Flask application file (e.g., `app.py`) to successfully register that route:

1.  **Import the function:** The function must be imported into the main file where the Flask app instance (`app`) is defined.
2.  **The Flask App Instance Must Exist:** The decorator (`@app.route(...)`) relies on the existence of the globally accessible `app` variable (the Flask application instance) *at the time the decorator is executed*.

Here is how you structure this across two files:

---

### File 1: `my_routes.py` (The File Containing the Logic)

This file holds the actual function that handles the request.

```python
# my_routes.py

from flask import request

def get_user_agent():
    """
    This function retrieves and returns the user agent.
    """
    user_agent = request.headers.get('User-Agent')

    if user_agent:
        return f"<h1>Your User Agent is:</h1><p>{user_agent}</p>"
    else:
        return "<h1>No User-Agent found in the request headers.</h1>"

# Note: This file does NOT need the 'app' variable or the @app.route decorator here.
```

---

### File 2: `app.py` (The Main Application Entry Point)

This file initializes Flask, imports the logic, and registers the route using the imported function.

```python
# app.py

from flask import Flask
# 1. Import the function from the other file
from my_routes import get_user_agent

# Create the Flask application instance
app = Flask(__name__)

# 2. Register the imported function to the route
@app.route('/')
def handle_user_agent_request():
    """
    This function acts as a wrapper, calling the function imported
    from my_routes.py
    """
    return get_user_agent()

# Optional: If you want to expose other routes from that file, you would import
# and register them similarly.

if __name__ == '__main__':
    # Run the app on http://127.0.0.1:5000/
    app.run(debug=True)
```

### Why this works:

When Python executes `app.py`:

1.  It creates the `app` object.
2.  It executes `from my_routes import get_user_agent`, making the function available locally in `app.py`.
3.  When the decorator `@app.route('/')` is processed, it looks up the function name provided right below it (`handle_user_agent_request`).
4.  The `handle_user_agent_request` function then calls the imported `get_user_agent()` function, which has access to the active request context (`request`) provided by Flask when the URL is hit.

### Alternative (Using Blueprints - The Cleaner Production Method)

For larger applications, the preferred method is to use **Flask Blueprints**. Blueprints allow you to organize routes, templates, and static files into separate modular components without globally exposing the `app` instance everywhere.

**1. `my_routes.py` (Now a Blueprint)**

```python
# my_routes.py
from flask import Blueprint, request

# Define a Blueprint named 'main'
main_bp = Blueprint('main', __name__)

@main_bp.route('/')
def get_user_agent():
    user_agent = request.headers.get('User-Agent')
    return f"<h1>Your User Agent is:</h1><p>{user_agent}</p>"
```

**2. `app.py` (Registering the Blueprint)**

```python
# app.py
from flask import Flask
from my_routes import main_bp # Import the blueprint object

app = Flask(__name__)

# Register the blueprint with the main application instance
app.register_blueprint(main_bp)

if __name__ == '__main__':
    app.run(debug=True)
```

In the Blueprint method, the route registration (`@main_bp.route`) is handled within the module where the logic resides, and the main `app.py` only needs to call `app.register_blueprint()`. This is much cleaner for scalability.
